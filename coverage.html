
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dwipurnomo515/yard-planning/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/dwipurnomo515/yard-planning/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/dwipurnomo515/yard-planning/internal/handler/bulk_handler.go (0.0%)</option>
				
				<option value="file3">github.com/dwipurnomo515/yard-planning/internal/handler/container_handler.go (0.0%)</option>
				
				<option value="file4">github.com/dwipurnomo515/yard-planning/internal/middleware/middleware.go (0.0%)</option>
				
				<option value="file5">github.com/dwipurnomo515/yard-planning/internal/repository/block_repository.go (0.0%)</option>
				
				<option value="file6">github.com/dwipurnomo515/yard-planning/internal/repository/container_repository.go (0.0%)</option>
				
				<option value="file7">github.com/dwipurnomo515/yard-planning/internal/repository/yard_plan_repository.go (0.0%)</option>
				
				<option value="file8">github.com/dwipurnomo515/yard-planning/internal/repository/yard_repository.go (86.4%)</option>
				
				<option value="file9">github.com/dwipurnomo515/yard-planning/internal/service/cached_container_service.go (0.0%)</option>
				
				<option value="file10">github.com/dwipurnomo515/yard-planning/internal/service/container_service.go (7.1%)</option>
				
				<option value="file11">github.com/dwipurnomo515/yard-planning/pkg/cache/redis.go (0.0%)</option>
				
				<option value="file12">github.com/dwipurnomo515/yard-planning/pkg/database/postgres.go (0.0%)</option>
				
				<option value="file13">github.com/dwipurnomo515/yard-planning/pkg/response/response.go (0.0%)</option>
				
				<option value="file14">github.com/dwipurnomo515/yard-planning/pkg/worker/pool.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "net/http"

        "github.com/dwipurnomo515/yard-planning/config"
        "github.com/dwipurnomo515/yard-planning/internal/handler"
        "github.com/dwipurnomo515/yard-planning/internal/middleware"
        "github.com/dwipurnomo515/yard-planning/internal/repository"
        "github.com/dwipurnomo515/yard-planning/internal/service"
        "github.com/dwipurnomo515/yard-planning/pkg/cache"
        "github.com/dwipurnomo515/yard-planning/pkg/database"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg := config.LoadConfig()

        // Initialize database
        db, err := database.NewPostgresDB(database.DBConfig{
                Host:     cfg.DBHost,
                Port:     cfg.DBPort,
                User:     cfg.DBUser,
                Password: cfg.DBPassword,
                DBName:   cfg.DBName,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to connect to database:", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Initialize repositories
        yardRepo := repository.NewYardRepository(db)
        blockRepo := repository.NewBlockRepository(db)
        planRepo := repository.NewYardPlanRepository(db)
        containerRepo := repository.NewContainerRepository(db)

        // Initialize services
        var containerHandler *handler.ContainerHandler
        var bulkHandler *handler.BulkHandler

        if cfg.EnableCache </span><span class="cov0" title="0">{
                // Initialize Redis client
                redisClient, err := cache.NewRedisClient(cache.RedisConfig{
                        Host:     cfg.RedisHost,
                        Port:     cfg.RedisPort,
                        Password: cfg.RedisPass,
                        DB:       cfg.RedisDB,
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to connect to Redis: %v. Running without cache.", err)
                        // Fall back to non-cached service
                        containerService := service.NewContainerService(
                                yardRepo,
                                blockRepo,
                                planRepo,
                                containerRepo,
                        )
                        containerHandler = handler.NewContainerHandler(containerService)
                        bulkHandler = handler.NewBulkHandler(containerService)
                }</span> else<span class="cov0" title="0"> {
                        defer redisClient.Close()
                        log.Println("Redis cache enabled")

                        // Use cached service
                        cachedService := service.NewCachedContainerService(
                                yardRepo,
                                blockRepo,
                                planRepo,
                                containerRepo,
                                redisClient,
                        )
                        // Convert to base service for handler
                        baseService := &amp;cachedService.ContainerService
                        containerHandler = handler.NewContainerHandler(baseService)
                        bulkHandler = handler.NewBulkHandler(baseService)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Println("Cache disabled")
                containerService := service.NewContainerService(
                        yardRepo,
                        blockRepo,
                        planRepo,
                        containerRepo,
                )
                containerHandler = handler.NewContainerHandler(containerService)
                bulkHandler = handler.NewBulkHandler(containerService)
        }</span>

        // Setup routes
        <span class="cov0" title="0">mux := http.NewServeMux()

        // Single operation endpoints
        mux.HandleFunc("/suggestion", containerHandler.HandleSuggestion)
        mux.HandleFunc("/placement", containerHandler.HandlePlacement)
        mux.HandleFunc("/pickup", containerHandler.HandlePickup)

        // Bulk operation endpoints (concurrent)
        mux.HandleFunc("/bulk/suggestion", bulkHandler.HandleBulkSuggestion)
        mux.HandleFunc("/bulk/placement", bulkHandler.HandleBulkPlacement)

        // Health check
        mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                w.Write([]byte("OK"))
        }</span>)

        // Apply middleware
        <span class="cov0" title="0">handlerWithMiddleware := middleware.Recovery(
                middleware.Logger(
                        middleware.CORS(
                                middleware.ContentType(mux),
                        ),
                ),
        )

        // Start server
        addr := ":" + cfg.ServerPort
        log.Printf("Server starting on %s", addr)
        log.Printf("Cache enabled: %v", cfg.EnableCache)
        if err := http.ListenAndServe(addr, handlerWithMiddleware); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server failed to start:", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "log"
        "os"

        "github.com/joho/godotenv"
)

type Config struct {
        DBHost      string
        DBPort      string
        DBUser      string
        DBPassword  string
        DBName      string
        ServerPort  string
        RedisHost   string
        RedisPort   string
        RedisPass   string
        RedisDB     int
        EnableCache bool
}

// LoadConfig loads configuration from environment variables
func LoadConfig() *Config <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Println("⚠️  .env file not found, using default or system environment variables")
        }</span>

        <span class="cov0" title="0">return &amp;Config{
                DBHost:     getEnv("DB_HOST", "localhost"),
                DBPort:     getEnv("DB_PORT", "5432"),
                DBUser:     getEnv("DB_USER", "postgres"),
                DBPassword: getEnv("DB_PASSWORD", "postgres"),
                DBName:     getEnv("DB_NAME", "yard_planning"),
                ServerPort: getEnv("SERVER_PORT", "8080"),
        }</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "context"
        "encoding/json"
        "net/http"
        "sync"

        "github.com/dwipurnomo515/yard-planning/internal/model"
        "github.com/dwipurnomo515/yard-planning/internal/service"
        "github.com/dwipurnomo515/yard-planning/pkg/response"
        "github.com/dwipurnomo515/yard-planning/pkg/worker"
)

type BulkHandler struct {
        service *service.ContainerService
}

func NewBulkHandler(service *service.ContainerService) *BulkHandler <span class="cov0" title="0">{
        return &amp;BulkHandler{service: service}
}</span>

// BulkSuggestionRequest represents bulk suggestion request
type BulkSuggestionRequest struct {
        Containers []model.SuggestionRequest `json:"containers"`
}

// BulkSuggestionResponse represents bulk suggestion response
type BulkSuggestionResponse struct {
        Results []SuggestionResult `json:"results"`
}

type SuggestionResult struct {
        ContainerNumber   string          `json:"container_number"`
        SuggestedPosition *model.Position `json:"suggested_position,omitempty"`
        Error             string          `json:"error,omitempty"`
}

// HandleBulkSuggestion handles bulk suggestion requests concurrently
func (h *BulkHandler) HandleBulkSuggestion(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                response.Error(w, http.StatusMethodNotAllowed, http.ErrNotSupported)
                return
        }</span>

        <span class="cov0" title="0">var req BulkSuggestionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">if len(req.Containers) == 0 </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, http.ErrMissingBoundary)
                return
        }</span>

        // Use worker pool for concurrent processing
        <span class="cov0" title="0">pool := worker.NewPool(5, func(ctx context.Context, job worker.Job) (interface{}, error) </span><span class="cov0" title="0">{
                suggReq := job.Payload.(model.SuggestionRequest)
                position, err := h.service.GetSuggestion(suggReq)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return position, nil</span>
        })

        <span class="cov0" title="0">pool.Start()

        // Submit jobs
        go func() </span><span class="cov0" title="0">{
                for _, container := range req.Containers </span><span class="cov0" title="0">{
                        pool.Submit(worker.Job{
                                ID:      container.ContainerNumber,
                                Payload: container,
                        })
                }</span>
                <span class="cov0" title="0">pool.Stop()</span>
        }()

        // Collect results
        <span class="cov0" title="0">results := make([]SuggestionResult, 0, len(req.Containers))
        for result := range pool.Results() </span><span class="cov0" title="0">{
                suggReq := result.Job.Payload.(model.SuggestionRequest)
                if result.Err != nil </span><span class="cov0" title="0">{
                        results = append(results, SuggestionResult{
                                ContainerNumber: suggReq.ContainerNumber,
                                Error:           result.Err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        position := result.Value.(*model.Position)
                        results = append(results, SuggestionResult{
                                ContainerNumber:   suggReq.ContainerNumber,
                                SuggestedPosition: position,
                        })
                }</span>
        }

        <span class="cov0" title="0">resp := BulkSuggestionResponse{Results: results}
        response.Success(w, resp)</span>
}

// BulkPlacementRequest represents bulk placement request
type BulkPlacementRequest struct {
        Containers []model.PlacementRequest `json:"containers"`
}

type PlacementResult struct {
        ContainerNumber string `json:"container_number"`
        Success         bool   `json:"success"`
        Error           string `json:"error,omitempty"`
}

type BulkPlacementResponse struct {
        Results []PlacementResult `json:"results"`
}

// HandleBulkPlacement handles bulk placement with concurrent execution
func (h *BulkHandler) HandleBulkPlacement(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                response.Error(w, http.StatusMethodNotAllowed, http.ErrNotSupported)
                return
        }</span>

        <span class="cov0" title="0">var req BulkPlacementRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">if len(req.Containers) == 0 </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, http.ErrMissingBoundary)
                return
        }</span>

        // Use goroutines with mutex for concurrent placement
        <span class="cov0" title="0">var (
                wg      sync.WaitGroup
                mu      sync.Mutex
                results []PlacementResult
        )

        // Limit concurrency to avoid overwhelming the database
        semaphore := make(chan struct{}, 10)

        for _, container := range req.Containers </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(c model.PlacementRequest) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Acquire semaphore
                        semaphore &lt;- struct{}{}
                        defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>()

                        <span class="cov0" title="0">err := h.service.PlaceContainer(c)

                        mu.Lock()
                        if err != nil </span><span class="cov0" title="0">{
                                results = append(results, PlacementResult{
                                        ContainerNumber: c.ContainerNumber,
                                        Success:         false,
                                        Error:           err.Error(),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                results = append(results, PlacementResult{
                                        ContainerNumber: c.ContainerNumber,
                                        Success:         true,
                                })
                        }</span>
                        <span class="cov0" title="0">mu.Unlock()</span>
                }(container)
        }

        <span class="cov0" title="0">wg.Wait()

        resp := BulkPlacementResponse{Results: results}
        response.Success(w, resp)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "encoding/json"
        "net/http"

        "github.com/dwipurnomo515/yard-planning/internal/model"
        "github.com/dwipurnomo515/yard-planning/internal/service"
        "github.com/dwipurnomo515/yard-planning/pkg/response"
)

type ContainerHandler struct {
        service *service.ContainerService
}

func NewContainerHandler(service *service.ContainerService) *ContainerHandler <span class="cov0" title="0">{
        return &amp;ContainerHandler{service: service}
}</span>

// HandleSuggestion handles POST /suggestion
func (h *ContainerHandler) HandleSuggestion(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                response.Error(w, http.StatusMethodNotAllowed,
                        http.ErrNotSupported)
                return
        }</span>

        <span class="cov0" title="0">var req model.SuggestionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err)
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.Yard == "" </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest,
                        http.ErrMissingBoundary)
                return
        }</span>
        <span class="cov0" title="0">if req.ContainerNumber == "" </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest,
                        http.ErrMissingBoundary)
                return
        }</span>

        <span class="cov0" title="0">position, err := h.service.GetSuggestion(req)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">resp := model.SuggestionResponse{
                SuggestedPosition: *position,
        }

        response.Success(w, resp)</span>
}

// HandlePlacement handles POST /placement
func (h *ContainerHandler) HandlePlacement(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                response.Error(w, http.StatusMethodNotAllowed,
                        http.ErrNotSupported)
                return
        }</span>

        <span class="cov0" title="0">var req model.PlacementRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err)
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.Yard == "" || req.ContainerNumber == "" || req.Block == "" </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest,
                        http.ErrMissingBoundary)
                return
        }</span>
        <span class="cov0" title="0">if req.Slot &lt; 1 || req.Row &lt; 1 || req.Tier &lt; 1 </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest,
                        http.ErrMissingBoundary)
                return
        }</span>

        <span class="cov0" title="0">err := h.service.PlaceContainer(req)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">resp := model.PlacementResponse{
                Message: "Success",
        }

        response.Success(w, resp)</span>
}

// HandlePickup handles POST /pickup
func (h *ContainerHandler) HandlePickup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                response.Error(w, http.StatusMethodNotAllowed,
                        http.ErrNotSupported)
                return
        }</span>

        <span class="cov0" title="0">var req model.PickupRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err)
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.Yard == "" || req.ContainerNumber == "" </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest,
                        http.ErrMissingBoundary)
                return
        }</span>

        <span class="cov0" title="0">err := h.service.PickupContainer(req)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">resp := model.PickupResponse{
                Message: "Success",
        }

        response.Success(w, resp)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import (
        "log"
        "net/http"
        "time"
)

// Logger middleware logs HTTP requests
func Logger(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // Create a response writer wrapper to capture status code
                rw := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                next.ServeHTTP(rw, r)

                log.Printf(
                        "%s %s %d %s",
                        r.Method,
                        r.RequestURI,
                        rw.statusCode,
                        time.Since(start),
                )
        }</span>)
}

// Recovery middleware recovers from panics
func Recovery(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("panic: %v", err)
                                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        }</span>
                }()

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// CORS middleware adds CORS headers
func CORS(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                // Handle preflight requests
                if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// ContentType middleware ensures requests have correct content type
func ContentType(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodPost || r.Method == http.MethodPut </span><span class="cov0" title="0">{
                        contentType := r.Header.Get("Content-Type")
                        if contentType != "application/json" </span><span class="cov0" title="0">{
                                http.Error(w, "Content-Type must be application/json", http.StatusUnsupportedMediaType)
                                return
                        }</span>
                }

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        "github.com/dwipurnomo515/yard-planning/internal/model"
)

type BlockRepository struct {
        db *sql.DB
}

func NewBlockRepository(db *sql.DB) *BlockRepository <span class="cov0" title="0">{
        return &amp;BlockRepository{db: db}
}</span>

// GetByYardAndCode retrieves a block by yard ID and block code
func (r *BlockRepository) GetByYardAndCode(yardID int, code string) (*model.Block, error) <span class="cov0" title="0">{
        query := `
                SELECT id, yard_id, code, name, max_slot, max_row, max_tier, created_at, updated_at
                FROM blocks
                WHERE yard_id = $1 AND code = $2
        `

        var block model.Block
        err := r.db.QueryRow(query, yardID, code).Scan(
                &amp;block.ID,
                &amp;block.YardID,
                &amp;block.Code,
                &amp;block.Name,
                &amp;block.MaxSlot,
                &amp;block.MaxRow,
                &amp;block.MaxTier,
                &amp;block.CreatedAt,
                &amp;block.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("block with code '%s' not found in yard", code)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying block: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;block, nil</span>
}

// GetByYardID retrieves all blocks for a specific yard
func (r *BlockRepository) GetByYardID(yardID int) ([]model.Block, error) <span class="cov0" title="0">{
        query := `
                SELECT id, yard_id, code, name, max_slot, max_row, max_tier, created_at, updated_at
                FROM blocks
                WHERE yard_id = $1
                ORDER BY code
        `

        rows, err := r.db.Query(query, yardID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying blocks: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var blocks []model.Block
        for rows.Next() </span><span class="cov0" title="0">{
                var block model.Block
                err := rows.Scan(
                        &amp;block.ID,
                        &amp;block.YardID,
                        &amp;block.Code,
                        &amp;block.Name,
                        &amp;block.MaxSlot,
                        &amp;block.MaxRow,
                        &amp;block.MaxTier,
                        &amp;block.CreatedAt,
                        &amp;block.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error scanning block: %w", err)
                }</span>
                <span class="cov0" title="0">blocks = append(blocks, block)</span>
        }

        <span class="cov0" title="0">return blocks, nil</span>
}

// GetByID retrieves a block by ID
func (r *BlockRepository) GetByID(id int) (*model.Block, error) <span class="cov0" title="0">{
        query := `
                SELECT id, yard_id, code, name, max_slot, max_row, max_tier, created_at, updated_at
                FROM blocks
                WHERE id = $1
        `

        var block model.Block
        err := r.db.QueryRow(query, id).Scan(
                &amp;block.ID,
                &amp;block.YardID,
                &amp;block.Code,
                &amp;block.Name,
                &amp;block.MaxSlot,
                &amp;block.MaxRow,
                &amp;block.MaxTier,
                &amp;block.CreatedAt,
                &amp;block.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("block with id %d not found", id)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying block: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;block, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        "github.com/dwipurnomo515/yard-planning/internal/model"
)

type ContainerRepository struct {
        db *sql.DB
}

func NewContainerRepository(db *sql.DB) *ContainerRepository <span class="cov0" title="0">{
        return &amp;ContainerRepository{db: db}
}</span>

// Create inserts a new container into the database
func (r *ContainerRepository) Create(container *model.Container) error <span class="cov0" title="0">{
        query := `
                INSERT INTO containers (
                        container_number, yard_id, block_id, slot, row, tier,
                        container_size, container_height, container_type
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id, placed_at
        `

        err := r.db.QueryRow(
                query,
                container.ContainerNumber,
                container.YardID,
                container.BlockID,
                container.Slot,
                container.Row,
                container.Tier,
                container.ContainerSize,
                container.ContainerHeight,
                container.ContainerType,
        ).Scan(&amp;container.ID, &amp;container.PlacedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating container: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByNumber retrieves a container by its number
func (r *ContainerRepository) GetByNumber(containerNumber string) (*model.Container, error) <span class="cov0" title="0">{
        query := `
                SELECT id, container_number, yard_id, block_id, slot, row, tier,
                       container_size, container_height, container_type, placed_at
                FROM containers
                WHERE container_number = $1
        `

        var container model.Container
        err := r.db.QueryRow(query, containerNumber).Scan(
                &amp;container.ID,
                &amp;container.ContainerNumber,
                &amp;container.YardID,
                &amp;container.BlockID,
                &amp;container.Slot,
                &amp;container.Row,
                &amp;container.Tier,
                &amp;container.ContainerSize,
                &amp;container.ContainerHeight,
                &amp;container.ContainerType,
                &amp;container.PlacedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container '%s' not found", containerNumber)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying container: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;container, nil</span>
}

// Delete removes a container from the database
func (r *ContainerRepository) Delete(containerNumber string) error <span class="cov0" title="0">{
        query := `DELETE FROM containers WHERE container_number = $1`

        result, err := r.db.Exec(query, containerNumber)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error deleting container: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("container '%s' not found", containerNumber)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsPositionOccupied checks if a specific position is occupied
// For 40ft containers, checks both slots
func (r *ContainerRepository) IsPositionOccupied(blockID, slot, row, tier int, containerSize int) (bool, error) <span class="cov0" title="0">{
        var query string
        var args []interface{}

        if containerSize == 40 </span><span class="cov0" title="0">{
                // Check both slot and slot+1 for 40ft container
                query = `
                        SELECT COUNT(*) &gt; 0
                        FROM containers
                        WHERE block_id = $1
                          AND row = $2
                          AND tier = $3
                          AND (slot = $4 OR slot = $5)
                `
                args = []interface{}{blockID, row, tier, slot, slot + 1}
        }</span> else<span class="cov0" title="0"> {
                // Check single slot for 20ft container
                query = `
                        SELECT COUNT(*) &gt; 0
                        FROM containers
                        WHERE block_id = $1
                          AND slot = $2
                          AND row = $3
                          AND tier = $4
                `
                args = []interface{}{blockID, slot, row, tier}
        }</span>

        <span class="cov0" title="0">var occupied bool
        err := r.db.QueryRow(query, args...).Scan(&amp;occupied)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error checking position: %w", err)
        }</span>

        <span class="cov0" title="0">return occupied, nil</span>
}

// GetOccupiedPositionsInArea retrieves all occupied positions within a specific area
func (r *ContainerRepository) GetOccupiedPositionsInArea(blockID, slotStart, slotEnd, rowStart, rowEnd int) ([]model.Container, error) <span class="cov0" title="0">{
        query := `
                SELECT id, container_number, yard_id, block_id, slot, row, tier,
                       container_size, container_height, container_type, placed_at
                FROM containers
                WHERE block_id = $1
                  AND slot &gt;= $2
                  AND slot &lt;= $3
                  AND row &gt;= $4
                  AND row &lt;= $5
                ORDER BY slot, row, tier
        `

        rows, err := r.db.Query(query, blockID, slotStart, slotEnd, rowStart, rowEnd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying containers: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var containers []model.Container
        for rows.Next() </span><span class="cov0" title="0">{
                var container model.Container
                err := rows.Scan(
                        &amp;container.ID,
                        &amp;container.ContainerNumber,
                        &amp;container.YardID,
                        &amp;container.BlockID,
                        &amp;container.Slot,
                        &amp;container.Row,
                        &amp;container.Tier,
                        &amp;container.ContainerSize,
                        &amp;container.ContainerHeight,
                        &amp;container.ContainerType,
                        &amp;container.PlacedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error scanning container: %w", err)
                }</span>
                <span class="cov0" title="0">containers = append(containers, container)</span>
        }

        <span class="cov0" title="0">return containers, nil</span>
}

// IsContainerBlocked checks if there's a container above the given position
func (r *ContainerRepository) IsContainerBlocked(blockID, slot, row, tier int) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*) &gt; 0
                FROM containers
                WHERE block_id = $1
                  AND slot = $2
                  AND row = $3
                  AND tier &gt; $4
        `

        var blocked bool
        err := r.db.QueryRow(query, blockID, slot, row, tier).Scan(&amp;blocked)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error checking if blocked: %w", err)
        }</span>

        <span class="cov0" title="0">return blocked, nil</span>
}

// GetAll retrieves all containers
func (r *ContainerRepository) GetAll() ([]model.Container, error) <span class="cov0" title="0">{
        query := `
                SELECT id, container_number, yard_id, block_id, slot, row, tier,
                       container_size, container_height, container_type, placed_at
                FROM containers
                ORDER BY placed_at DESC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying containers: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var containers []model.Container
        for rows.Next() </span><span class="cov0" title="0">{
                var container model.Container
                err := rows.Scan(
                        &amp;container.ID,
                        &amp;container.ContainerNumber,
                        &amp;container.YardID,
                        &amp;container.BlockID,
                        &amp;container.Slot,
                        &amp;container.Row,
                        &amp;container.Tier,
                        &amp;container.ContainerSize,
                        &amp;container.ContainerHeight,
                        &amp;container.ContainerType,
                        &amp;container.PlacedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error scanning container: %w", err)
                }</span>
                <span class="cov0" title="0">containers = append(containers, container)</span>
        }

        <span class="cov0" title="0">return containers, nil</span>
}

// GetByBlock retrieves all containers in a specific block
func (r *ContainerRepository) GetByBlock(blockID int) ([]model.Container, error) <span class="cov0" title="0">{
        query := `
                SELECT id, container_number, yard_id, block_id, slot, row, tier,
                       container_size, container_height, container_type, placed_at
                FROM containers
                WHERE block_id = $1
                ORDER BY slot, row, tier
        `

        rows, err := r.db.Query(query, blockID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying containers: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var containers []model.Container
        for rows.Next() </span><span class="cov0" title="0">{
                var container model.Container
                err := rows.Scan(
                        &amp;container.ID,
                        &amp;container.ContainerNumber,
                        &amp;container.YardID,
                        &amp;container.BlockID,
                        &amp;container.Slot,
                        &amp;container.Row,
                        &amp;container.Tier,
                        &amp;container.ContainerSize,
                        &amp;container.ContainerHeight,
                        &amp;container.ContainerType,
                        &amp;container.PlacedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error scanning container: %w", err)
                }</span>
                <span class="cov0" title="0">containers = append(containers, container)</span>
        }

        <span class="cov0" title="0">return containers, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        "github.com/dwipurnomo515/yard-planning/internal/model"
)

type YardPlanRepository struct {
        db *sql.DB
}

func NewYardPlanRepository(db *sql.DB) *YardPlanRepository <span class="cov0" title="0">{
        return &amp;YardPlanRepository{db: db}
}</span>

// FindMatchingPlan finds a yard plan that matches the container specifications
func (r *YardPlanRepository) FindMatchingPlan(blockID int, size int, height float64, containerType string) (*model.YardPlan, error) <span class="cov0" title="0">{
        query := `
                SELECT id, block_id, slot_start, slot_end, row_start, row_end,
                       container_size, container_height, container_type, stacking_priority,
                       created_at, updated_at
                FROM yard_plans
                WHERE block_id = $1
                  AND container_size = $2
                  AND container_height = $3
                  AND container_type = $4
                LIMIT 1
        `

        var plan model.YardPlan
        err := r.db.QueryRow(query, blockID, size, height, containerType).Scan(
                &amp;plan.ID,
                &amp;plan.BlockID,
                &amp;plan.SlotStart,
                &amp;plan.SlotEnd,
                &amp;plan.RowStart,
                &amp;plan.RowEnd,
                &amp;plan.ContainerSize,
                &amp;plan.ContainerHeight,
                &amp;plan.ContainerType,
                &amp;plan.StackingPriority,
                &amp;plan.CreatedAt,
                &amp;plan.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no yard plan found for container size=%d, height=%.1f, type=%s", size, height, containerType)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying yard plan: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;plan, nil</span>
}

// GetByBlockID retrieves all yard plans for a specific block
func (r *YardPlanRepository) GetByBlockID(blockID int) ([]model.YardPlan, error) <span class="cov0" title="0">{
        query := `
                SELECT id, block_id, slot_start, slot_end, row_start, row_end,
                       container_size, container_height, container_type, stacking_priority,
                       created_at, updated_at
                FROM yard_plans
                WHERE block_id = $1
                ORDER BY slot_start, row_start
        `

        rows, err := r.db.Query(query, blockID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying yard plans: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var plans []model.YardPlan
        for rows.Next() </span><span class="cov0" title="0">{
                var plan model.YardPlan
                err := rows.Scan(
                        &amp;plan.ID,
                        &amp;plan.BlockID,
                        &amp;plan.SlotStart,
                        &amp;plan.SlotEnd,
                        &amp;plan.RowStart,
                        &amp;plan.RowEnd,
                        &amp;plan.ContainerSize,
                        &amp;plan.ContainerHeight,
                        &amp;plan.ContainerType,
                        &amp;plan.StackingPriority,
                        &amp;plan.CreatedAt,
                        &amp;plan.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error scanning yard plan: %w", err)
                }</span>
                <span class="cov0" title="0">plans = append(plans, plan)</span>
        }

        <span class="cov0" title="0">return plans, nil</span>
}

// Create creates a new yard plan
func (r *YardPlanRepository) Create(plan *model.YardPlan) error <span class="cov0" title="0">{
        query := `
                INSERT INTO yard_plans (
                        block_id, slot_start, slot_end, row_start, row_end,
                        container_size, container_height, container_type, stacking_priority
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id, created_at, updated_at
        `

        err := r.db.QueryRow(
                query,
                plan.BlockID,
                plan.SlotStart,
                plan.SlotEnd,
                plan.RowStart,
                plan.RowEnd,
                plan.ContainerSize,
                plan.ContainerHeight,
                plan.ContainerType,
                plan.StackingPriority,
        ).Scan(&amp;plan.ID, &amp;plan.CreatedAt, &amp;plan.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating yard plan: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        "github.com/dwipurnomo515/yard-planning/internal/model"
)

type YardRepository struct {
        db *sql.DB
}

func NewYardRepository(db *sql.DB) *YardRepository <span class="cov8" title="1">{
        return &amp;YardRepository{db: db}
}</span>

// GetByCode retrieves a yard by its code
func (r *YardRepository) GetByCode(code string) (*model.Yard, error) <span class="cov8" title="1">{
        query := `
                SELECT id, code, name, description, created_at, updated_at
                FROM yards
                WHERE code = $1
        `

        var yard model.Yard
        err := r.db.QueryRow(query, code).Scan(
                &amp;yard.ID,
                &amp;yard.Code,
                &amp;yard.Name,
                &amp;yard.Description,
                &amp;yard.CreatedAt,
                &amp;yard.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("yard with code '%s' not found", code)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying yard: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;yard, nil</span>
}

// GetAll retrieves all yards
func (r *YardRepository) GetAll() ([]model.Yard, error) <span class="cov8" title="1">{
        query := `
                SELECT id, code, name, description, created_at, updated_at
                FROM yards
                ORDER BY code
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying yards: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var yards []model.Yard
        for rows.Next() </span><span class="cov8" title="1">{
                var yard model.Yard
                err := rows.Scan(
                        &amp;yard.ID,
                        &amp;yard.Code,
                        &amp;yard.Name,
                        &amp;yard.Description,
                        &amp;yard.CreatedAt,
                        &amp;yard.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error scanning yard: %w", err)
                }</span>
                <span class="cov8" title="1">yards = append(yards, yard)</span>
        }

        <span class="cov8" title="1">return yards, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package service

import (
        "fmt"
        "time"

        "github.com/dwipurnomo515/yard-planning/internal/model"
        "github.com/dwipurnomo515/yard-planning/internal/repository"
        "github.com/dwipurnomo515/yard-planning/pkg/cache"
)

type CachedContainerService struct {
        ContainerService
        cache *cache.RedisClient
}

func NewCachedContainerService(
        yardRepo *repository.YardRepository,
        blockRepo *repository.BlockRepository,
        planRepo *repository.YardPlanRepository,
        containerRepo *repository.ContainerRepository,
        redisClient *cache.RedisClient,
) *CachedContainerService <span class="cov0" title="0">{
        return &amp;CachedContainerService{
                ContainerService: ContainerService{
                        yardRepo:      yardRepo,
                        blockRepo:     blockRepo,
                        planRepo:      planRepo,
                        containerRepo: containerRepo,
                },
                cache: redisClient,
        }
}</span>

// GetSuggestion with caching
func (s *CachedContainerService) GetSuggestion(req model.SuggestionRequest) (*model.Position, error) <span class="cov0" title="0">{
        // Validate input
        if err := s.validateContainerSpec(req.ContainerSize, req.ContainerHeight, req.ContainerType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Try to get from cache
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("suggestion:%s:%d:%.1f:%s",
                req.Yard, req.ContainerSize, req.ContainerHeight, req.ContainerType)

        var cachedPosition model.Position
        if err := s.cache.Get(cacheKey, &amp;cachedPosition); err == nil </span><span class="cov0" title="0">{
                // Verify position is still available
                yard, _ := s.yardRepo.GetByCode(req.Yard)
                if yard != nil </span><span class="cov0" title="0">{
                        block, _ := s.blockRepo.GetByYardAndCode(yard.ID, cachedPosition.Block)
                        if block != nil </span><span class="cov0" title="0">{
                                occupied, _ := s.containerRepo.IsPositionOccupied(
                                        block.ID,
                                        cachedPosition.Slot,
                                        cachedPosition.Row,
                                        cachedPosition.Tier,
                                        req.ContainerSize,
                                )
                                if !occupied </span><span class="cov0" title="0">{
                                        return &amp;cachedPosition, nil
                                }</span>
                        }
                }
                // Cache invalid, delete it
                <span class="cov0" title="0">s.cache.Delete(cacheKey)</span>
        }

        // Get fresh suggestion
        <span class="cov0" title="0">position, err := s.ContainerService.GetSuggestion(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Cache the result for 5 minutes
        <span class="cov0" title="0">s.cache.Set(cacheKey, position, 5*time.Minute)

        return position, nil</span>
}

// PlaceContainer with cache invalidation
func (s *CachedContainerService) PlaceContainer(req model.PlacementRequest) error <span class="cov0" title="0">{
        err := s.ContainerService.PlaceContainer(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Invalidate related caches
        <span class="cov0" title="0">pattern := fmt.Sprintf("suggestion:%s:*", req.Yard)
        s.cache.DeletePattern(pattern)

        // Cache the container position
        cacheKey := fmt.Sprintf("container:%s", req.ContainerNumber)
        containerInfo := map[string]interface{}{
                "yard":  req.Yard,
                "block": req.Block,
                "slot":  req.Slot,
                "row":   req.Row,
                "tier":  req.Tier,
        }
        s.cache.Set(cacheKey, containerInfo, 24*time.Hour)

        return nil</span>
}

// PickupContainer with cache invalidation
func (s *CachedContainerService) PickupContainer(req model.PickupRequest) error <span class="cov0" title="0">{
        err := s.ContainerService.PickupContainer(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Invalidate caches
        <span class="cov0" title="0">pattern := fmt.Sprintf("suggestion:%s:*", req.Yard)
        s.cache.DeletePattern(pattern)

        // Remove container cache
        cacheKey := fmt.Sprintf("container:%s", req.ContainerNumber)
        s.cache.Delete(cacheKey)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package service

import (
        "fmt"

        "github.com/dwipurnomo515/yard-planning/internal/model"
        "github.com/dwipurnomo515/yard-planning/internal/repository"
)

type ContainerService struct {
        yardRepo      *repository.YardRepository
        blockRepo     *repository.BlockRepository
        planRepo      *repository.YardPlanRepository
        containerRepo *repository.ContainerRepository
}

func NewContainerService(
        yardRepo *repository.YardRepository,
        blockRepo *repository.BlockRepository,
        planRepo *repository.YardPlanRepository,
        containerRepo *repository.ContainerRepository,
) *ContainerService <span class="cov0" title="0">{
        return &amp;ContainerService{
                yardRepo:      yardRepo,
                blockRepo:     blockRepo,
                planRepo:      planRepo,
                containerRepo: containerRepo,
        }
}</span>

// GetSuggestion suggests a position for a container based on yard plans
func (s *ContainerService) GetSuggestion(req model.SuggestionRequest) (*model.Position, error) <span class="cov0" title="0">{
        // Validate input
        if err := s.validateContainerSpec(req.ContainerSize, req.ContainerHeight, req.ContainerType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get yard
        <span class="cov0" title="0">yard, err := s.yardRepo.GetByCode(req.Yard)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get blocks in yard
        <span class="cov0" title="0">blocks, err := s.blockRepo.GetByYardID(yard.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Try to find available position in each block
        <span class="cov0" title="0">for _, block := range blocks </span><span class="cov0" title="0">{
                // Find matching yard plan
                plan, err := s.planRepo.FindMatchingPlan(
                        block.ID,
                        req.ContainerSize,
                        req.ContainerHeight,
                        req.ContainerType,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Try next block
                }

                // Find available position in this plan
                <span class="cov0" title="0">position := s.findAvailablePosition(block, *plan)
                if position != nil </span><span class="cov0" title="0">{
                        return position, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no available position found for container")</span>
}

// PlaceContainer places a container at a specific position
func (s *ContainerService) PlaceContainer(req model.PlacementRequest) error <span class="cov0" title="0">{
        // Validate input
        if req.ContainerNumber == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("container number is required")
        }</span>

        // Get yard
        <span class="cov0" title="0">yard, err := s.yardRepo.GetByCode(req.Yard)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get block
        <span class="cov0" title="0">block, err := s.blockRepo.GetByYardAndCode(yard.ID, req.Block)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate position
        <span class="cov0" title="0">if err := s.validatePosition(block, req.Slot, req.Row, req.Tier); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if container already exists
        <span class="cov0" title="0">existingContainer, _ := s.containerRepo.GetByNumber(req.ContainerNumber)
        if existingContainer != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("container '%s' already placed in yard", req.ContainerNumber)
        }</span>

        // For now, we'll use default container specs (20ft, 8.6, DRY)
        // In production, you'd want to pass these in the request
        <span class="cov0" title="0">containerSize := 20
        containerHeight := 8.6
        containerType := "DRY"

        // Check if position is available
        occupied, err := s.containerRepo.IsPositionOccupied(block.ID, req.Slot, req.Row, req.Tier, containerSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if occupied </span><span class="cov0" title="0">{
                return fmt.Errorf("position is already occupied")
        }</span>

        // Check if tier &gt; 1, ensure tier below is occupied
        <span class="cov0" title="0">if req.Tier &gt; 1 </span><span class="cov0" title="0">{
                occupied, err := s.containerRepo.IsPositionOccupied(block.ID, req.Slot, req.Row, req.Tier-1, containerSize)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !occupied </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot place container at tier %d: tier below is empty", req.Tier)
                }</span>
        }

        // Create container
        <span class="cov0" title="0">container := &amp;model.Container{
                ContainerNumber: req.ContainerNumber,
                YardID:          yard.ID,
                BlockID:         block.ID,
                Slot:            req.Slot,
                Row:             req.Row,
                Tier:            req.Tier,
                ContainerSize:   containerSize,
                ContainerHeight: containerHeight,
                ContainerType:   containerType,
        }

        return s.containerRepo.Create(container)</span>
}

// PickupContainer removes a container from the yard
func (s *ContainerService) PickupContainer(req model.PickupRequest) error <span class="cov0" title="0">{
        // Validate input
        if req.ContainerNumber == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("container number is required")
        }</span>

        // Get yard
        <span class="cov0" title="0">_, err := s.yardRepo.GetByCode(req.Yard)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get container
        <span class="cov0" title="0">container, err := s.containerRepo.GetByNumber(req.ContainerNumber)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if container is blocked (has containers on top)
        <span class="cov0" title="0">blocked, err := s.containerRepo.IsContainerBlocked(
                container.BlockID,
                container.Slot,
                container.Row,
                container.Tier,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if blocked </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot pickup container: there are containers on top")
        }</span>

        // Delete container
        <span class="cov0" title="0">return s.containerRepo.Delete(req.ContainerNumber)</span>
}

// Helper methods

func (s *ContainerService) validateContainerSpec(size int, height float64, containerType string) error <span class="cov8" title="1">{
        if size != 20 &amp;&amp; size != 40 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid container size: must be 20 or 40")
        }</span>
        <span class="cov8" title="1">if height != 8.6 &amp;&amp; height != 9.6 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid container height: must be 8.6 or 9.6")
        }</span>
        <span class="cov8" title="1">validTypes := map[string]bool{"DRY": true, "REEFER": true, "OPEN_TOP": true}
        if !validTypes[containerType] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid container type: must be DRY, REEFER, or OPEN_TOP")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *ContainerService) validatePosition(block *model.Block, slot, row, tier int) error <span class="cov0" title="0">{
        if slot &lt; 1 || slot &gt; block.MaxSlot </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid slot: must be between 1 and %d", block.MaxSlot)
        }</span>
        <span class="cov0" title="0">if row &lt; 1 || row &gt; block.MaxRow </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid row: must be between 1 and %d", block.MaxRow)
        }</span>
        <span class="cov0" title="0">if tier &lt; 1 || tier &gt; block.MaxTier </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid tier: must be between 1 and %d", block.MaxTier)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *ContainerService) findAvailablePosition(block model.Block, plan model.YardPlan) *model.Position <span class="cov0" title="0">{
        // Get all occupied positions in this plan's area
        occupied, err := s.containerRepo.GetOccupiedPositionsInArea(
                block.ID,
                plan.SlotStart,
                plan.SlotEnd,
                plan.RowStart,
                plan.RowEnd,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create map of occupied positions
        <span class="cov0" title="0">occupiedMap := make(map[string]bool)
        for _, c := range occupied </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%d-%d-%d", c.Slot, c.Row, c.Tier)
                occupiedMap[key] = true

                // For 40ft containers, mark second slot as occupied too
                if c.ContainerSize == 40 </span><span class="cov0" title="0">{
                        key2 := fmt.Sprintf("%d-%d-%d", c.Slot+1, c.Row, c.Tier)
                        occupiedMap[key2] = true
                }</span>
        }

        // Find first available position (tier 1 first, then stack up)
        <span class="cov0" title="0">for tier := 1; tier &lt;= block.MaxTier; tier++ </span><span class="cov0" title="0">{
                for slot := plan.SlotStart; slot &lt;= plan.SlotEnd; slot++ </span><span class="cov0" title="0">{
                        for row := plan.RowStart; row &lt;= plan.RowEnd; row++ </span><span class="cov0" title="0">{
                                // For 40ft, need to check if both slots are available
                                slotsNeeded := 1
                                if plan.ContainerSize == 40 </span><span class="cov0" title="0">{
                                        slotsNeeded = 2
                                        // Make sure we don't exceed slot range
                                        if slot+1 &gt; plan.SlotEnd </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                }

                                // Check if position is available
                                <span class="cov0" title="0">available := true
                                for s := 0; s &lt; slotsNeeded; s++ </span><span class="cov0" title="0">{
                                        key := fmt.Sprintf("%d-%d-%d", slot+s, row, tier)
                                        if occupiedMap[key] </span><span class="cov0" title="0">{
                                                available = false
                                                break</span>
                                        }
                                }

                                <span class="cov0" title="0">if !available </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // For tier &gt; 1, check if tier below is occupied
                                <span class="cov0" title="0">if tier &gt; 1 </span><span class="cov0" title="0">{
                                        tierBelowOccupied := true
                                        for s := 0; s &lt; slotsNeeded; s++ </span><span class="cov0" title="0">{
                                                keyBelow := fmt.Sprintf("%d-%d-%d", slot+s, row, tier-1)
                                                if !occupiedMap[keyBelow] </span><span class="cov0" title="0">{
                                                        tierBelowOccupied = false
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !tierBelowOccupied </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                }

                                // Found available position
                                <span class="cov0" title="0">return &amp;model.Position{
                                        Block: block.Code,
                                        Slot:  slot,
                                        Row:   row,
                                        Tier:  tier,
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

type RedisClient struct {
        client *redis.Client
        ctx    context.Context
}

type RedisConfig struct {
        Host     string
        Port     string
        Password string
        DB       int
}

// NewRedisClient creates a new Redis client
func NewRedisClient(cfg RedisConfig) (*RedisClient, error) <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     fmt.Sprintf("%s:%s", cfg.Host, cfg.Port),
                Password: cfg.Password,
                DB:       cfg.DB,
        })

        ctx := context.Background()

        // Test connection
        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error connecting to redis: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;RedisClient{
                client: client,
                ctx:    ctx,
        }, nil</span>
}

// Set stores a value in Redis with expiration
func (r *RedisClient) Set(key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        json, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshaling value: %w", err)
        }</span>

        <span class="cov0" title="0">return r.client.Set(r.ctx, key, json, expiration).Err()</span>
}

// Get retrieves a value from Redis
func (r *RedisClient) Get(key string, dest interface{}) error <span class="cov0" title="0">{
        val, err := r.client.Get(r.ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("key not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting value: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(val), dest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error unmarshaling value: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete removes a key from Redis
func (r *RedisClient) Delete(key string) error <span class="cov0" title="0">{
        return r.client.Del(r.ctx, key).Err()
}</span>

// DeletePattern deletes all keys matching a pattern
func (r *RedisClient) DeletePattern(pattern string) error <span class="cov0" title="0">{
        iter := r.client.Scan(r.ctx, 0, pattern, 0).Iterator()
        for iter.Next(r.ctx) </span><span class="cov0" title="0">{
                if err := r.client.Del(r.ctx, iter.Val()).Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting key: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return iter.Err()</span>
}

// Exists checks if a key exists
func (r *RedisClient) Exists(key string) (bool, error) <span class="cov0" title="0">{
        result, err := r.client.Exists(r.ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return result &gt; 0, nil</span>
}

// Close closes the Redis connection
func (r *RedisClient) Close() error <span class="cov0" title="0">{
        return r.client.Close()
}</span>

// GetClient returns the underlying Redis client
func (r *RedisClient) GetClient() *redis.Client <span class="cov0" title="0">{
        return r.client
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"

        _ "github.com/lib/pq"
)

type DBConfig struct {
        Host     string
        Port     string
        User     string
        Password string
        DBName   string
}

// NewPostgresDB creates a new PostgreSQL database connection
func NewPostgresDB(cfg DBConfig) (*sql.DB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf(
                "host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName,
        )

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening database: %w", err)
        }</span>

        // Test connection
        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error connecting to database: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)

        log.Println("Database connection established successfully")
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package response

import (
        "encoding/json"
        "net/http"
)

type ErrorResponse struct {
        Error   string `json:"error"`
        Message string `json:"message,omitempty"`
}

// JSON writes a JSON response
func JSON(w http.ResponseWriter, status int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
        }</span>
}

// Error writes an error response
func Error(w http.ResponseWriter, status int, err error) <span class="cov0" title="0">{
        JSON(w, status, ErrorResponse{
                Error:   http.StatusText(status),
                Message: err.Error(),
        })
}</span>

// Success writes a success response
func Success(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        JSON(w, http.StatusOK, data)
}</span>

// Created writes a created response
func Created(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        JSON(w, http.StatusCreated, data)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package worker

import (
        "context"
        "sync"
)

// Job represents a unit of work
type Job struct {
        ID      string
        Payload interface{}
}

// Result represents the result of a job
type Result struct {
        Job   Job
        Value interface{}
        Err   error
}

// Worker function type
type WorkerFunc func(ctx context.Context, job Job) (interface{}, error)

// Pool represents a worker pool
type Pool struct {
        workers    int
        jobs       chan Job
        results    chan Result
        workerFunc WorkerFunc
        wg         sync.WaitGroup
        ctx        context.Context
        cancel     context.CancelFunc
}

// NewPool creates a new worker pool
func NewPool(workers int, workerFunc WorkerFunc) *Pool <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;Pool{
                workers:    workers,
                jobs:       make(chan Job, workers*2),
                results:    make(chan Result, workers*2),
                workerFunc: workerFunc,
                ctx:        ctx,
                cancel:     cancel,
        }
}</span>

// Start starts the worker pool
func (p *Pool) Start() <span class="cov0" title="0">{
        for i := 0; i &lt; p.workers; i++ </span><span class="cov0" title="0">{
                p.wg.Add(1)
                go p.worker(i)
        }</span>
}

// worker is the worker goroutine
func (p *Pool) worker(id int) <span class="cov0" title="0">{
        defer p.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-p.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case job, ok := &lt;-p.jobs:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">value, err := p.workerFunc(p.ctx, job)
                        p.results &lt;- Result{
                                Job:   job,
                                Value: value,
                                Err:   err,
                        }</span>
                }
        }
}

// Submit submits a job to the pool
func (p *Pool) Submit(job Job) <span class="cov0" title="0">{
        p.jobs &lt;- job
}</span>

// Results returns the results channel
func (p *Pool) Results() &lt;-chan Result <span class="cov0" title="0">{
        return p.results
}</span>

// Stop stops the worker pool
func (p *Pool) Stop() <span class="cov0" title="0">{
        close(p.jobs)
        p.wg.Wait()
        close(p.results)
}</span>

// StopWithCancel stops the pool and cancels all running jobs
func (p *Pool) StopWithCancel() <span class="cov0" title="0">{
        p.cancel()
        p.Stop()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
